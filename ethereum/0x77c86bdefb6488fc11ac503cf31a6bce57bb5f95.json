{"address":"0x77C86bdeFB6488Fc11Ac503CF31a6BCE57Bb5F95","name":"","metadata":{"compiler":{"version":"0.6.12+commit.27d51765"},"language":"Solidity","output":{"abi":[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"proxy","type":"address"}],"name":"ProxyCreated","type":"event"},{"inputs":[{"internalType":"address","name":"user","type":"address"},{"internalType":"contract TokenFaucet[]","name":"tokenFaucets","type":"address[]"}],"name":"claimAll","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"contract IERC20Upgradeable","name":"_asset","type":"address"},{"internalType":"contract IERC20Upgradeable","name":"_measure","type":"address"},{"internalType":"uint256","name":"_dripRatePerSecond","type":"uint256"}],"name":"create","outputs":[{"internalType":"contract TokenFaucet","name":"","type":"address"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"contract IERC20Upgradeable","name":"_asset","type":"address"},{"internalType":"contract IERC20Upgradeable","name":"_measure","type":"address"},{"internalType":"uint256","name":"_dripRatePerSecond","type":"uint256"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"createAndDeposit","outputs":[{"internalType":"contract TokenFaucet","name":"","type":"address"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_logic","type":"address"},{"internalType":"bytes","name":"_data","type":"bytes"}],"name":"deployMinimal","outputs":[{"internalType":"address","name":"proxy","type":"address"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"instance","outputs":[{"internalType":"contract TokenFaucet","name":"","type":"address"}],"stateMutability":"view","type":"function"}],"devdoc":{"kind":"dev","methods":{"claimAll(address,address[])":{"params":{"tokenFaucets":"The tokenFaucets to call claim on.","user":"The user to claim for"}},"create(address,address,uint256)":{"params":{"_asset":"The asset to disburse to users","_dripRatePerSecond":"The amount of the asset to drip each second","_measure":"The token to use to measure a users portion"},"returns":{"_0":"A reference to the new proxied TokenFaucet"}},"createAndDeposit(address,address,uint256,uint256)":{"params":{"_amount":"The amount of assets to deposit into the faucet","_asset":"The asset to disburse to users","_dripRatePerSecond":"The amount of the asset to drip each second","_measure":"The token to use to measure a users portion"},"returns":{"_0":"A reference to the new proxied TokenFaucet"}}},"title":"Stake Prize Pool Proxy Factory","version":1},"userdoc":{"kind":"user","methods":{"claimAll(address,address[])":{"notice":"Runs claim on all passed comptrollers for a user."},"constructor":"Initializes the Factory with an instance of the TokenFaucet","create(address,address,uint256)":{"notice":"Creates a new TokenFaucet"},"createAndDeposit(address,address,uint256,uint256)":{"notice":"Creates a new TokenFaucet and immediately deposits funds"},"instance()":{"notice":"Contract template for deploying proxied Comptrollers"}},"notice":"Minimal proxy pattern for creating new TokenFaucet contracts","version":1}},"settings":{"compilationTarget":{"contracts/token-faucet/TokenFaucetProxyFactory.sol":"TokenFaucetProxyFactory"},"evmVersion":"istanbul","libraries":{},"metadata":{"bytecodeHash":"ipfs","useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[]},"sources":{"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n    uint256[49] private __gap;\n}\n","keccak256":"0xb419e68addcb82ecda3ad3974b0d2db76435ce9b08435a04d5b119a0c5d45ea5","license":"MIT"},"@openzeppelin/contracts-upgradeable/introspection/IERC165Upgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n","keccak256":"0x4784c3f8a520a739dd25d76f514833a653990902d0e21601aed45bda44c87524","license":"MIT"},"@openzeppelin/contracts-upgradeable/introspection/IERC1820RegistryUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the global ERC1820 Registry, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\n * implementers for interfaces in this registry, as well as query support.\n *\n * Implementers may be shared by multiple accounts, and can also implement more\n * than a single interface for each account. Contracts can implement interfaces\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\n * contract.\n *\n * {IERC165} interfaces can also be queried via the registry.\n *\n * For an in-depth explanation and source code analysis, see the EIP text.\n */\ninterface IERC1820RegistryUpgradeable {\n    /**\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\n     * account is able to set interface implementers for it.\n     *\n     * By default, each account is its own manager. Passing a value of `0x0` in\n     * `newManager` will reset the manager to this initial state.\n     *\n     * Emits a {ManagerChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     */\n    function setManager(address account, address newManager) external;\n\n    /**\n     * @dev Returns the manager for `account`.\n     *\n     * See {setManager}.\n     */\n    function getManager(address account) external view returns (address);\n\n    /**\n     * @dev Sets the `implementer` contract as ``account``'s implementer for\n     * `interfaceHash`.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     * The zero address can also be used in `implementer` to remove an old one.\n     *\n     * See {interfaceHash} to learn how these are created.\n     *\n     * Emits an {InterfaceImplementerSet} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\n     * end in 28 zeroes).\n     * - `implementer` must implement {IERC1820Implementer} and return true when\n     * queried for support, unless `implementer` is the caller. See\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\n     */\n    function setInterfaceImplementer(address account, bytes32 _interfaceHash, address implementer) external;\n\n    /**\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\n     * implementer is registered, returns the zero address.\n     *\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\n     * zeroes), `account` will be queried for support of it.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     */\n    function getInterfaceImplementer(address account, bytes32 _interfaceHash) external view returns (address);\n\n    /**\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\n     * corresponding\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\n     */\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\n\n    /**\n     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n     *  @param account Address of the contract for which to update the cache.\n     *  @param interfaceId ERC165 interface for which to update the cache.\n     */\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\n\n    /**\n     *  @notice Checks whether a contract implements an ERC165 interface or not.\n     *  If the result is not cached a direct lookup on the contract address is performed.\n     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n     *  {updateERC165Cache} with the contract address.\n     *  @param account Address of the contract to check.\n     *  @param interfaceId ERC165 interface to check.\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\n\n    /**\n     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n     *  @param account Address of the contract to check.\n     *  @param interfaceId ERC165 interface to check.\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\n\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\n\n    event ManagerChanged(address indexed account, address indexed newManager);\n}\n","keccak256":"0xc8f73c50cb3cf3dc80d09c82e9c265d778f30a2801c5ff394aca3be7dd064acd","license":"MIT"},"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMathUpgradeable {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n","keccak256":"0x0dd1e9b19801e3e7d900fbf4182d81e1afd23ad7be39504e33df6bbcba91d724","license":"MIT"},"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol":{"content":"// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.4.24 <0.8.0;\n\nimport \"../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n","keccak256":"0xd8e4eb08dcc1d1860fb347ba5ffd595242b9a1b66d49a47f2b4cb51c3f35017e","license":"MIT"},"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n","keccak256":"0xa1931c47a617014f858580db625aa0dcf343796f39acd4b5b51effc092a1f0a9","license":"MIT"},"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n","keccak256":"0xfc5ea91fa9ceb1961023b2a6c978b902888c52b90847ac7813fe3b79524165f6","license":"MIT"},"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\nimport \"../proxy/Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n","keccak256":"0xbbf8a21b9a66c48d45ff771b8563c6df19ba451d63dfb8380a865c1e1f29d1a0","license":"MIT"},"@openzeppelin/contracts-upgradeable/utils/SafeCastUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCastUpgradeable {\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= -2**127 && value < 2**127, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= -2**63 && value < 2**63, \"SafeCast: value doesn\\'t fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= -2**31 && value < 2**31, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= -2**15 && value < 2**15, \"SafeCast: value doesn\\'t fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= -2**7 && value < 2**7, \"SafeCast: value doesn\\'t fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n","keccak256":"0x8bba8b7cb2b7a53b4b669acdaeeafc697502e1d762716f1110a9a99bff1f1c4d","license":"MIT"},"@pooltogether/fixed-point/contracts/FixedPoint.sol":{"content":"/**\nCopyright 2020 PoolTogether Inc.\n\nThis file is part of PoolTogether.\n\nPoolTogether is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation under version 3 of the License.\n\nPoolTogether is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./external/openzeppelin/OpenZeppelinSafeMath_V3_3_0.sol\";\n\n/**\n * @author Brendan Asselstine\n * @notice Provides basic fixed point math calculations.\n *\n * This library calculates integer fractions by scaling values by 1e18 then performing standard integer math.\n */\nlibrary FixedPoint {\n    using OpenZeppelinSafeMath_V3_3_0 for uint256;\n\n    // The scale to use for fixed point numbers.  Same as Ether for simplicity.\n    uint256 internal constant SCALE = 1e18;\n\n    /**\n        * Calculates a Fixed18 mantissa given the numerator and denominator\n        *\n        * The mantissa = (numerator * 1e18) / denominator\n        *\n        * @param numerator The mantissa numerator\n        * @param denominator The mantissa denominator\n        * @return The mantissa of the fraction\n        */\n    function calculateMantissa(uint256 numerator, uint256 denominator) internal pure returns (uint256) {\n        uint256 mantissa = numerator.mul(SCALE);\n        mantissa = mantissa.div(denominator);\n        return mantissa;\n    }\n\n    /**\n        * Multiplies a Fixed18 number by an integer.\n        *\n        * @param b The whole integer to multiply\n        * @param mantissa The Fixed18 number\n        * @return An integer that is the result of multiplying the params.\n        */\n    function multiplyUintByMantissa(uint256 b, uint256 mantissa) internal pure returns (uint256) {\n        uint256 result = mantissa.mul(b);\n        result = result.div(SCALE);\n        return result;\n    }\n\n    /**\n    * Divides an integer by a fixed point 18 mantissa\n    *\n    * @param dividend The integer to divide\n    * @param mantissa The fixed point 18 number to serve as the divisor\n    * @return An integer that is the result of dividing an integer by a fixed point 18 mantissa\n    */\n    function divideUintByMantissa(uint256 dividend, uint256 mantissa) internal pure returns (uint256) {\n        uint256 result = SCALE.mul(dividend);\n        result = result.div(mantissa);\n        return result;\n    }\n}\n","keccak256":"0x282e7d707b1e604481fed02d1290cde78470e288d3469940c2edf9e5b8a10d99"},"@pooltogether/fixed-point/contracts/external/openzeppelin/OpenZeppelinSafeMath_V3_3_0.sol":{"content":"// SPDX-License-Identifier: MIT\n\n// NOTE: Copied from OpenZeppelin Contracts version 3.3.0\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary OpenZeppelinSafeMath_V3_3_0 {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n","keccak256":"0xd57327a27dee007aead634ed97dd9ffa42b2626eb2731368650c9cb0e50e73d4","license":"MIT"},"contracts/Constants.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.6.0 <0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/introspection/IERC1820RegistryUpgradeable.sol\";\n\nlibrary Constants {\n  IERC1820RegistryUpgradeable public constant REGISTRY = IERC1820RegistryUpgradeable(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n  // keccak256(\"ERC777TokensSender\")\n  bytes32 public constant TOKENS_SENDER_INTERFACE_HASH =\n  0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895;\n\n  // keccak256(\"ERC777TokensRecipient\")\n  bytes32 public constant TOKENS_RECIPIENT_INTERFACE_HASH =\n  0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;\n\n  // keccak256(abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\"));\n  bytes32 public constant ACCEPT_MAGIC =\n  0xa2ef4600d742022d532d4747cb3547474667d6f13804902513b2ec01c848f4b4;\n\n  bytes4 public constant ERC165_INTERFACE_ID_ERC165 = 0x01ffc9a7;\n  bytes4 public constant ERC165_INTERFACE_ID_ERC721 = 0x80ac58cd;\n}","keccak256":"0x8481c6d291103f2826aa16d3a291680c0182a6b8b754b0b1c7c63b11fb0b5eb3","license":"GPL-3.0"},"contracts/external/openzeppelin/ProxyFactory.sol":{"content":"pragma solidity >=0.6.0 <0.7.0;\n\n// solium-disable security/no-inline-assembly\n// solium-disable security/no-low-level-calls\ncontract ProxyFactory {\n\n  event ProxyCreated(address proxy);\n\n  function deployMinimal(address _logic, bytes memory _data) public returns (address proxy) {\n    // Adapted from https://github.com/optionality/clone-factory/blob/32782f82dfc5a00d103a7e61a17a5dedbd1e8e9d/contracts/CloneFactory.sol\n    bytes20 targetBytes = bytes20(_logic);\n    assembly {\n      let clone := mload(0x40)\n      mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n      mstore(add(clone, 0x14), targetBytes)\n      mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n      proxy := create(0, clone, 0x37)\n    }\n\n    emit ProxyCreated(address(proxy));\n\n    if(_data.length > 0) {\n      (bool success,) = proxy.call(_data);\n      require(success, \"ProxyFactory/constructor-call-failed\");\n    }\n  }\n}\n","keccak256":"0x571028e27d301916b4d956f9f6442a57203a3a43bda705fa8db7e23010d4c136"},"contracts/token-faucet/TokenFaucet.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.6.0 <0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/SafeCastUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@pooltogether/fixed-point/contracts/FixedPoint.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"../utils/ExtendedSafeCast.sol\";\nimport \"../token/TokenListener.sol\";\n\n/// @title Disburses a token at a fixed rate per second to holders of another token.\n/// @notice The tokens are dripped at a \"drip rate per second\".  This is the number of tokens that\n/// are dripped each second.  A user's share of the dripped tokens is based on how many 'measure' tokens they hold.\n/* solium-disable security/no-block-members */\ncontract TokenFaucet is OwnableUpgradeable, TokenListener {\n  using SafeMathUpgradeable for uint256;\n  using SafeCastUpgradeable for uint256;\n  using ExtendedSafeCast for uint256;\n\n  event Initialized(\n    IERC20Upgradeable indexed asset,\n    IERC20Upgradeable indexed measure,\n    uint256 dripRatePerSecond\n  );\n\n  event Dripped(\n    uint256 newTokens\n  );\n\n  event Deposited(\n    address indexed user,\n    uint256 amount\n  );\n\n  event Withdrawn(\n    address indexed to,\n    uint256 amount\n  );\n\n  event Claimed(\n    address indexed user,\n    uint256 newTokens\n  );\n\n  event DripRateChanged(\n    uint256 dripRatePerSecond\n  );\n\n  struct UserState {\n    uint128 lastExchangeRateMantissa;\n    uint128 balance;\n  }\n\n  /// @notice The token that is being disbursed\n  IERC20Upgradeable public asset;\n\n  /// @notice The token that is user to measure a user's portion of disbursed tokens\n  IERC20Upgradeable public measure;\n\n  /// @notice The total number of tokens that are disbursed each second\n  uint256 public dripRatePerSecond;\n\n  /// @notice The cumulative exchange rate of measure token supply : dripped tokens\n  uint112 public exchangeRateMantissa;\n\n  /// @notice The total amount of tokens that have been dripped but not claimed\n  uint112 public totalUnclaimed;\n\n  /// @notice The timestamp at which the tokens were last dripped\n  uint32 public lastDripTimestamp;\n\n  /// @notice The data structure that tracks when a user last received tokens\n  mapping(address => UserState) public userStates;\n\n  /// @notice Initializes a new Comptroller V2\n  /// @param _asset The asset to disburse to users\n  /// @param _measure The token to use to measure a users portion\n  /// @param _dripRatePerSecond The amount of the asset to drip each second\n  function initialize (\n    IERC20Upgradeable _asset,\n    IERC20Upgradeable _measure,\n    uint256 _dripRatePerSecond\n  ) public initializer {\n    __Ownable_init();\n    lastDripTimestamp = _currentTime();\n    asset = _asset;\n    measure = _measure;\n    setDripRatePerSecond(_dripRatePerSecond);\n\n    emit Initialized(\n      asset,\n      measure,\n      dripRatePerSecond\n    );\n  }\n\n  /// @notice Safely deposits asset tokens into the faucet.  Must be pre-approved\n  /// This should be used instead of transferring directly because the drip function must\n  /// be called before receiving new assets.\n  /// @param amount The amount of asset tokens to add (must be approved already)\n  function deposit(uint256 amount) external {\n    drip();\n    asset.transferFrom(msg.sender, address(this), amount);\n\n    emit Deposited(msg.sender, amount);\n  }\n\n  /// @notice Allows the owner to withdraw tokens that have not been dripped yet.\n  /// @param to The address to withdraw to\n  /// @param amount The amount to withdraw\n  function withdrawTo(address to, uint256 amount) external onlyOwner {\n    drip();\n    uint256 assetTotalSupply = asset.balanceOf(address(this));\n    uint256 availableTotalSupply = assetTotalSupply.sub(totalUnclaimed);\n    require(amount <= availableTotalSupply, \"TokenFaucet/insufficient-funds\");\n    asset.transfer(to, amount);\n\n    emit Withdrawn(to, amount);\n  }\n\n  /// @notice Transfers all unclaimed tokens to the user\n  /// @param user The user to claim tokens for\n  /// @return The amount of tokens that were claimed.\n  function claim(address user) external returns (uint256) {\n    drip();\n    _captureNewTokensForUser(user);\n    uint256 balance = userStates[user].balance;\n    userStates[user].balance = 0;\n    totalUnclaimed = uint256(totalUnclaimed).sub(balance).toUint112();\n    asset.transfer(user, balance);\n\n    emit Claimed(user, balance);\n\n    return balance;\n  }\n\n  /// @notice Drips new tokens.\n  /// @dev Should be called immediately before any measure token mints/transfers/burns\n  /// @return The number of new tokens dripped.\n  function drip() public returns (uint256) {\n    uint256 currentTimestamp = _currentTime();\n\n    // this should only run once per block.\n    if (lastDripTimestamp == uint32(currentTimestamp)) {\n      return 0;\n    }\n\n    uint256 assetTotalSupply = asset.balanceOf(address(this));\n    uint256 availableTotalSupply = assetTotalSupply.sub(totalUnclaimed);\n    uint256 newSeconds = currentTimestamp.sub(lastDripTimestamp);\n    uint256 nextExchangeRateMantissa = exchangeRateMantissa;\n    uint256 newTokens;\n    uint256 measureTotalSupply = measure.totalSupply();\n\n    if (measureTotalSupply > 0 && availableTotalSupply > 0) {\n      newTokens = newSeconds.mul(dripRatePerSecond);\n      if (newTokens > availableTotalSupply) {\n        newTokens = availableTotalSupply;\n      }\n      uint256 indexDeltaMantissa = FixedPoint.calculateMantissa(newTokens, measureTotalSupply);\n      nextExchangeRateMantissa = nextExchangeRateMantissa.add(indexDeltaMantissa);\n\n      emit Dripped(\n        newTokens\n      );\n    }\n\n    exchangeRateMantissa = nextExchangeRateMantissa.toUint112();\n    totalUnclaimed = uint256(totalUnclaimed).add(newTokens).toUint112();\n    lastDripTimestamp = currentTimestamp.toUint32();\n\n    return newTokens;\n  }\n\n  /// @notice Allows the owner to set the drip rate per second.  This is the number of tokens that are dripped each second.\n  /// @param _dripRatePerSecond The new drip rate in tokens per second\n  function setDripRatePerSecond(uint256 _dripRatePerSecond) public onlyOwner {\n    require(_dripRatePerSecond > 0, \"TokenFaucet/dripRate-gt-zero\");\n\n    // ensure we're all caught up\n    drip();\n\n    dripRatePerSecond = _dripRatePerSecond;\n\n    emit DripRateChanged(dripRatePerSecond);\n  }\n\n  /// @notice Captures new tokens for a user\n  /// @dev This must be called before changes to the user's balance (i.e. before mint, transfer or burns)\n  /// @param user The user to capture tokens for\n  /// @return The number of new tokens\n  function _captureNewTokensForUser(\n    address user\n  ) private returns (uint128) {\n    UserState storage userState = userStates[user];\n    if (exchangeRateMantissa == userState.lastExchangeRateMantissa) {\n      // ignore if exchange rate is same\n      return 0;\n    }\n    uint256 deltaExchangeRateMantissa = uint256(exchangeRateMantissa).sub(userState.lastExchangeRateMantissa);\n    uint256 userMeasureBalance = measure.balanceOf(user);\n    uint128 newTokens = FixedPoint.multiplyUintByMantissa(userMeasureBalance, deltaExchangeRateMantissa).toUint128();\n\n    userStates[user] = UserState({\n      lastExchangeRateMantissa: exchangeRateMantissa,\n      balance: uint256(userState.balance).add(newTokens).toUint128()\n    });\n\n    return newTokens;\n  }\n\n  /// @notice Should be called before a user mints new \"measure\" tokens.\n  /// @param to The user who is minting the tokens\n  /// @param token The token they are minting\n  function beforeTokenMint(\n    address to,\n    uint256,\n    address token,\n    address\n  )\n    external\n    override\n  {\n    if (token == address(measure)) {\n      drip();\n      _captureNewTokensForUser(to);\n    }\n  }\n\n  /// @notice Should be called before \"measure\" tokens are transferred or burned\n  /// @param from The user who is sending the tokens\n  /// @param to The user who is receiving the tokens\n  /// @param token The token token they are burning\n  function beforeTokenTransfer(\n    address from,\n    address to,\n    uint256,\n    address token\n  )\n    external\n    override\n  {\n    // must be measure and not be minting\n    if (token == address(measure) && from != address(0)) {\n      drip();\n      _captureNewTokensForUser(to);\n      _captureNewTokensForUser(from);\n    }\n  }\n\n  /// @notice returns the current time.  Allows for override in testing.\n  /// @return The current time (block.timestamp)\n  function _currentTime() internal virtual view returns (uint32) {\n    return block.timestamp.toUint32();\n  }\n\n}\n","keccak256":"0xa39a8ab71c9d9fd6b323bf08d2f82f7694015026bb8912c986c541e590879605","license":"GPL-3.0"},"contracts/token-faucet/TokenFaucetProxyFactory.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.6.0 <0.7.0;\n\nimport \"./TokenFaucet.sol\";\nimport \"../external/openzeppelin/ProxyFactory.sol\";\n\n/// @title Stake Prize Pool Proxy Factory\n/// @notice Minimal proxy pattern for creating new TokenFaucet contracts\ncontract TokenFaucetProxyFactory is ProxyFactory {\n\n  /// @notice Contract template for deploying proxied Comptrollers\n  TokenFaucet public instance;\n\n  /// @notice Initializes the Factory with an instance of the TokenFaucet\n  constructor () public {\n    instance = new TokenFaucet();\n  }\n\n  /// @notice Creates a new TokenFaucet\n  /// @param _asset The asset to disburse to users\n  /// @param _measure The token to use to measure a users portion\n  /// @param _dripRatePerSecond The amount of the asset to drip each second\n  /// @return A reference to the new proxied TokenFaucet\n  function create(\n    IERC20Upgradeable _asset,\n    IERC20Upgradeable _measure,\n    uint256 _dripRatePerSecond\n  ) public returns (TokenFaucet) {\n    TokenFaucet tokenFaucet = TokenFaucet(deployMinimal(address(instance), \"\"));\n    tokenFaucet.initialize(\n      _asset, _measure, _dripRatePerSecond\n    );\n    tokenFaucet.transferOwnership(msg.sender);\n    return tokenFaucet;\n  }\n\n  /// @notice Creates a new TokenFaucet and immediately deposits funds\n  /// @param _asset The asset to disburse to users\n  /// @param _measure The token to use to measure a users portion\n  /// @param _dripRatePerSecond The amount of the asset to drip each second\n  /// @param _amount The amount of assets to deposit into the faucet\n  /// @return A reference to the new proxied TokenFaucet\n  function createAndDeposit(\n    IERC20Upgradeable _asset,\n    IERC20Upgradeable _measure,\n    uint256 _dripRatePerSecond,\n    uint256 _amount\n  ) external returns (TokenFaucet) {\n    TokenFaucet faucet = create(_asset, _measure, _dripRatePerSecond);\n    _asset.transferFrom(msg.sender, address(faucet), _amount);\n  }\n\n  /// @notice Runs claim on all passed comptrollers for a user.\n  /// @param user The user to claim for\n  /// @param tokenFaucets The tokenFaucets to call claim on.\n  function claimAll(address user, TokenFaucet[] calldata tokenFaucets) external {\n    for (uint256 i = 0; i < tokenFaucets.length; i++) {\n      tokenFaucets[i].claim(user);\n    }\n  }\n}\n","keccak256":"0xb4786ee9d5384fdcc7c190a7e0944c22fc7ccbd04374e6738356583bf66095dc","license":"GPL-3.0"},"contracts/token/TokenListener.sol":{"content":"pragma solidity ^0.6.4;\n\nimport \"./TokenListenerInterface.sol\";\nimport \"./TokenListenerLibrary.sol\";\nimport \"../Constants.sol\";\n\nabstract contract TokenListener is TokenListenerInterface {\n  function supportsInterface(bytes4 interfaceId) external override view returns (bool) {\n    return (\n      interfaceId == Constants.ERC165_INTERFACE_ID_ERC165 || \n      interfaceId == TokenListenerLibrary.ERC165_INTERFACE_ID_TOKEN_LISTENER\n    );\n  }\n}\n","keccak256":"0xb0e98d10b004602e1d4f4369a70e6382002dc0c0c5713698eb6a92943aef2265"},"contracts/token/TokenListenerInterface.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0 <0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/introspection/IERC165Upgradeable.sol\";\n\n/// @title An interface that allows a contract to listen to token mint, transfer and burn events.\ninterface TokenListenerInterface is IERC165Upgradeable {\n  /// @notice Called when tokens are minted.\n  /// @param to The address of the receiver of the minted tokens.\n  /// @param amount The amount of tokens being minted\n  /// @param controlledToken The address of the token that is being minted\n  /// @param referrer The address that referred the minting.\n  function beforeTokenMint(address to, uint256 amount, address controlledToken, address referrer) external;\n\n  /// @notice Called when tokens are transferred or burned.\n  /// @param from The address of the sender of the token transfer\n  /// @param to The address of the receiver of the token transfer.  Will be the zero address if burning.\n  /// @param amount The amount of tokens transferred\n  /// @param controlledToken The address of the token that was transferred\n  function beforeTokenTransfer(address from, address to, uint256 amount, address controlledToken) external;\n}\n","keccak256":"0x86b29792852503c80fc94e3040d1648f4c5bef59a3786582410db6d63de12a0a","license":"GPL-3.0"},"contracts/token/TokenListenerLibrary.sol":{"content":"pragma solidity ^0.6.12;\n\nlibrary TokenListenerLibrary {\n  /*\n    *     bytes4(keccak256('beforeTokenMint(address,uint256,address,address)')) == 0x4d7f3db0\n    *     bytes4(keccak256('beforeTokenTransfer(address,address,uint256,address)')) == 0xb2210957\n    *\n    *     => 0x4d7f3db0 ^ 0xb2210957 == 0xff5e34e7\n    */\n  bytes4 public constant ERC165_INTERFACE_ID_TOKEN_LISTENER = 0xff5e34e7;\n}","keccak256":"0x3ed670015409e43fcf0fa2e4094e4fe171f0b99681dedfef81eeece34af4cfcd"},"contracts/utils/ExtendedSafeCast.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.6.0 <0.7.0;\n\nlibrary ExtendedSafeCast {\n\n  /**\n    * @dev Converts an unsigned uint256 into a unsigned uint112.\n    *\n    * Requirements:\n    *\n    * - input must be less than or equal to maxUint112.\n    */\n  function toUint112(uint256 value) internal pure returns (uint112) {\n    require(value < 2**112, \"SafeCast: value doesn't fit in an uint112\");\n    return uint112(value);\n  }\n\n  /**\n    * @dev Converts an unsigned uint256 into a unsigned uint96.\n    *\n    * Requirements:\n    *\n    * - input must be less than or equal to maxUint96.\n    */\n  function toUint96(uint256 value) internal pure returns (uint96) {\n    require(value < 2**96, \"SafeCast: value doesn't fit in an uint96\");\n    return uint96(value);\n  }\n\n}","keccak256":"0x5d148bcc213678809ef19419650e351ecfa794708d6a168a7b2c10974f79f761","license":"GPL-3.0"}},"version":1},"version":1,"checkPoints":[]}