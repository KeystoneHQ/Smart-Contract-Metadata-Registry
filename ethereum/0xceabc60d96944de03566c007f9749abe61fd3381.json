{"address":"0xceabC60d96944DE03566c007f9749aBe61Fd3381","name":"","metadata":{"compiler":{"version":"0.8.3+commit.8d00100c"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"string","name":"_name","type":"string"},{"internalType":"string","name":"_symbol","type":"string"},{"internalType":"uint256[]","name":"_tokenCIDs","type":"uint256[]"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"_owner","type":"address"},{"indexed":true,"internalType":"address","name":"_approved","type":"address"},{"indexed":true,"internalType":"uint256","name":"_tokenId","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"_owner","type":"address"},{"indexed":true,"internalType":"address","name":"_operator","type":"address"},{"indexed":false,"internalType":"bool","name":"_approved","type":"bool"}],"name":"ApprovalForAll","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"_from","type":"address"},{"indexed":true,"internalType":"address","name":"_to","type":"address"},{"indexed":true,"internalType":"uint256","name":"_tokenId","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[{"internalType":"address","name":"_approved","type":"address"},{"internalType":"uint256","name":"_tokenId","type":"uint256"}],"name":"approve","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_tokenId","type":"uint256"}],"name":"burn","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"_tokenId","type":"uint256"}],"name":"getApproved","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_owner","type":"address"},{"internalType":"address","name":"_operator","type":"address"}],"name":"isApprovedForAll","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_tokenCID","type":"uint256"}],"name":"mint","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256[]","name":"_tokenCIDs","type":"uint256[]"}],"name":"mintMultiple","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_tokenId","type":"uint256"}],"name":"ownerOf","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_from","type":"address"},{"internalType":"address","name":"_to","type":"address"},{"internalType":"uint256","name":"_tokenId","type":"uint256"}],"name":"safeTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_from","type":"address"},{"internalType":"address","name":"_to","type":"address"},{"internalType":"uint256","name":"_tokenId","type":"uint256"},{"internalType":"bytes","name":"_data","type":"bytes"}],"name":"safeTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_operator","type":"address"},{"internalType":"bool","name":"_approved","type":"bool"}],"name":"setApprovalForAll","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"_interfaceID","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_tokenId","type":"uint256"}],"name":"tokenURI","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_from","type":"address"},{"internalType":"address","name":"_to","type":"address"},{"internalType":"uint256","name":"_tokenId","type":"uint256"}],"name":"transferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"}],"devdoc":{"details":"A simple 1 of 1 NFT implementation","events":{"Approval(address,address,uint256)":{"details":"This emits when the approved address for an NFT is changed or reaffirmed. The zero address indicates there is no approved address. When a Transfer event emits, this also indicates that the approved address for that NFT (if any) is reset to none."},"ApprovalForAll(address,address,bool)":{"details":"This emits when an operator is enabled or disabled for an owner. The operator can manage all NFTs of the owner."},"Transfer(address,address,uint256)":{"details":"Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any number of NFTs may be created and assigned without emitting Transfer. At the time of any transfer, the approved address for that NFT (if any) is reset to none."}},"kind":"dev","methods":{"approve(address,uint256)":{"details":"Set or reaffirm the approved address for an NFT.","params":{"_approved":"The new approved NFT controller.","_tokenId":"The NFT to approve."}},"balanceOf(address)":{"details":"Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are considered invalid, and this function throws for queries about the zero address.","params":{"_owner":"Address for whom to query the balance."},"returns":{"_0":"Balance of _owner."}},"constructor":{"details":"Setup NFT name and symbol and optionally mint a batch"},"decimals()":{"details":"For ERC-20 compatibility"},"getApproved(uint256)":{"details":"Get the approved address for a single NFT.","params":{"_tokenId":"The NFT to find the approved address for."},"returns":{"_0":"Address that _tokenId is approved for."}},"isApprovedForAll(address,address)":{"details":"Returns true if `_operator` is an approved operator for `_owner`, false otherwise.","params":{"_operator":"The address that acts on behalf of the owner.","_owner":"The address that owns the NFTs."},"returns":{"_0":"True if approved for all, false otherwise."}},"mint(uint256)":{"details":"Mint a NFT","params":{"_tokenCID":"The IPFS CID, minus the first two bytes which for practical purposes are the fixed values 0x12 0x20. (The tool that generates the IPFS CID should check that the first two bytes are 0x12 0x20 and remove them before calling the mint function.)"}},"mintMultiple(uint256[])":{"details":"Mint several NFTs at once","params":{"_tokenCIDs":"[] The IPFS CIDs"}},"ownerOf(uint256)":{"details":"Returns the address of the owner of the NFT. NFTs assigned to the zero address are considered invalid, and queries about them do throw.","params":{"_tokenId":"The identifier for an NFT."},"returns":{"_0":"Address of _tokenId owner."}},"safeTransferFrom(address,address,uint256)":{"details":"Transfers the ownership of an NFT from one address to another address.","params":{"_from":"The current owner of the NFT.","_to":"The new owner.","_tokenId":"The NFT to transfer."}},"safeTransferFrom(address,address,uint256,bytes)":{"details":"Transfers the ownership of an NFT from one address to another address.","params":{"_data":"Additional data with no specified format, sent in call to `_to`.","_from":"The current owner of the NFT.","_to":"The new owner.","_tokenId":"The NFT to transfer."}},"setApprovalForAll(address,bool)":{"details":"Enables or disables approval for a third party (\"operator\") to manage all of `msg.sender`'s assets. It also emits the ApprovalForAll event.","params":{"_approved":"True if the operators is approved, false to revoke approval.","_operator":"Address to add to the set of authorized operators."}},"supportsInterface(bytes4)":{"details":"Function to check which interfaces are suported by this contract.","params":{"_interfaceID":"Id of the interface."},"returns":{"_0":"True if _interfaceID is supported, false otherwise."}},"tokenURI(uint256)":{"details":"Returns a distinct Uniform Resource Identifier (URI) for a given asset. It Throws if `_tokenId` is not a valid NFT.","returns":{"_0":"URI of _tokenId."}},"transferFrom(address,address,uint256)":{"details":"Throws unless `msg.sender` is the current owner, an authorized operator, or the approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero address. Throws if `_tokenId` is not a valid NFT.","params":{"_from":"The current owner of the NFT.","_to":"The new owner.","_tokenId":"The NFT to transfer."}}},"stateVariables":{"ALPHABET":{"details":"Converts bytes to base58 encoded string. Used to compute the IPFS tokenURI on-the-fly."}},"title":"ERC721Token","version":1},"userdoc":{"kind":"user","methods":{"approve(address,uint256)":{"notice":"The zero address indicates there is no approved address. Throws unless `msg.sender` is the current NFT owner, or an authorized operator of the current owner."},"getApproved(uint256)":{"notice":"Throws if `_tokenId` is not a valid NFT."},"safeTransferFrom(address,address,uint256)":{"notice":"This works identically to the other function with an extra data parameter, except this function just sets data to \"\""},"safeTransferFrom(address,address,uint256,bytes)":{"notice":"Throws unless `msg.sender` is the current owner, an authorized operator, or the approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this function checks if `_to` is a smart contract (code size > 0). If so, it calls `onERC721Received` on `_to` and throws if the return value is not `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`."},"setApprovalForAll(address,bool)":{"notice":"The contract MUST allow multiple operators per owner."},"transferFrom(address,address,uint256)":{"notice":"The caller is responsible to confirm that `_to` is capable of receiving NFTs or else they may be permanently lost."}},"version":1}},"settings":{"compilationTarget":{"contracts/NFT.sol":"ERC721Token"},"evmVersion":"istanbul","libraries":{},"metadata":{"bytecodeHash":"ipfs"},"optimizer":{"enabled":true,"runs":200},"remappings":[]},"sources":{"contracts/NFT.sol":{"keccak256":"0x16e82380281ac9a4d587e7dba78b8144be3ca4d4da9b0360ce73442a094b812c","license":"MIT","urls":["bzz-raw://5b6326c0ffb7d05b34beb02a05e30fb641c773f0aa645dccf0f5166c15f86558","dweb:/ipfs/QmUudTf2twk6bnxgyoVX4tgthRGv6xA6NGcPJkMaQ6dAmg"]}},"version":1},"version":1,"checkPoints":[]}